import { Plugin } from 'vite';
import { watch, FSWatcher } from 'chokidar';
import { existsSync, readFileSync, statSync } from 'fs';
import { resolve, dirname, basename } from 'path';

interface BidirectionalWatchOptions {
  enabled?: boolean;
  srcComponentsPath?: string;
  sectionsPath?: string;
  debounceMs?: number;
}

export function bidirectionalWatch(options: BidirectionalWatchOptions = {}): Plugin {
  const {
    enabled = false,
    srcComponentsPath = 'src/components',
    sectionsPath = 'sections',
    debounceMs = 300
  } = options;

  let liquidWatcher: FSWatcher | null = null;
  let isViteWatching = false;
  let lastProcessedFiles = new Map<string, number>();

  function startLiquidWatcher() {
    if (liquidWatcher) {
      liquidWatcher.close();
    }

    console.log('👁️  [BIDIRECTIONAL-WATCH] Watching Liquid files in:');
    console.log(`   - ${srcComponentsPath}/**/*.liquid`);
    console.log(`   - ${sectionsPath}/**/*.liquid`);

    liquidWatcher = watch([
      `${srcComponentsPath}/**/*.liquid`,
      `${sectionsPath}/**/*.liquid`
    ], {
      ignored: /node_modules/,
      persistent: true,
      ignoreInitial: true,
    });

    liquidWatcher.on('change', (filePath) => handleLiquidChange(filePath, 'change'));
    liquidWatcher.on('add', (filePath) => handleLiquidChange(filePath, 'add'));
    liquidWatcher.on('unlink', (filePath) => handleLiquidChange(filePath, 'unlink'));
  }

  function handleLiquidChange(filePath: string, event: 'change' | 'add' | 'unlink') {
    const now = Date.now();
    const lastProcessed = lastProcessedFiles.get(filePath) || 0;
    
    if (now - lastProcessed < debounceMs) {
      return;
    }
    
    lastProcessedFiles.set(filePath, now);

    if (event === 'change' && isUserModification(filePath)) {
      notifyLiquidManualChange(filePath, event);
      checkReactLiquidConsistency(filePath);
    }
  }

  function isUserModification(liquidPath: string): boolean {
    try {
      const content = readFileSync(liquidPath, 'utf-8');
      
      const autoGeneratedMarkers = [
        'Auto-generated by Reactpify',
        'NO editar manualmente',
        'REACTPIFY-AUTOGEN',
        'Generated automatically'
      ];

      const hasAutoMarkers = autoGeneratedMarkers.some(marker => content.includes(marker));
      
      return !hasAutoMarkers;
    } catch (error) {
      console.warn(`⚠️ [BIDIRECTIONAL-WATCH] Could not verify ${liquidPath}:`, error);
      return false;
    }
  }

  function notifyLiquidManualChange(liquidPath: string, event: string) {
    console.log(`🔧 [BIDIRECTIONAL-WATCH] Manual change detected in: ${liquidPath}`);
    console.log(`   Event: ${event}`);
    console.log(`   💡 The Liquid file was manually modified by the user`);
  }

  function checkReactLiquidConsistency(liquidPath: string) {
    const componentName = extractComponentName(liquidPath);
    if (!componentName) return;

    const reactPath = resolve(srcComponentsPath, componentName, `${componentName}.tsx`);
    
    if (existsSync(reactPath)) {
      try {
        const liquidStat = statSync(liquidPath);
        const reactStat = statSync(reactPath);
        
        if (reactStat.mtime > liquidStat.mtime) {
          console.log(`⚠️ [BIDIRECTIONAL-WATCH] React component ${componentName}.tsx is newer than its Liquid file`);
          console.log(`   Consider regenerating the Liquid file to maintain synchronization`);
        }
      } catch (error) {
        console.warn(`⚠️ [BIDIRECTIONAL-WATCH] Error checking file dates:`, error);
      }
    }
  }

  function extractComponentName(liquidPath: string): string | null {
    const fileName = basename(liquidPath, '.liquid');
    
    if (fileName.startsWith('section.')) {
      return kebabCase(fileName.replace('section.', ''));
    }
    
    return kebabCase(fileName);
  }

  function kebabCase(str: string): string {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  }

  function cleanup() {
    if (liquidWatcher) {
      console.log('🧹 [BIDIRECTIONAL-WATCH] Closing watchers...');
      liquidWatcher.close();
      liquidWatcher = null;
    }
  }

  return {
    name: 'reactpify-bidirectional-watch',
    
    configureServer(server) {
      if (!enabled) return;
      
      isViteWatching = true;
      console.log('👀 [BIDIRECTIONAL-WATCH] Bidirectional watch system started');
      startLiquidWatcher();
      
      process.on('SIGINT', () => {
        cleanup();
        process.exit(0);
      });
      
      process.on('SIGTERM', () => {
        cleanup();
        process.exit(0);
      });
    },

    buildStart() {
      if (!isViteWatching && enabled) {
        console.log('🔄 [BIDIRECTIONAL-WATCH] Starting in build mode');
        startLiquidWatcher();
      }
    },

    buildEnd() {
      if (!isViteWatching) {
        cleanup();
      }
    }
  };
} 